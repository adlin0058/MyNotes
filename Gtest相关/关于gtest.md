## 用途
1. 进行单元测试
2. 测试C++程序的结果预期
3. 提供 丰富的断言、致命和非致命判断、参数化、死亡测试

## 什么是单元测试
1. 对于软件中的最小可测试单元进行检查和测试
2. 单元可大可小，可以是函数、方法、类、功能模块
3. 基本等同于白盒测试

## 优势
1. 测试是独立和可重复的
2. 测试有良好的组织，可反映被测试代码的结构，易于维护
3. 测试是可移植的和重复使用的
4. 在测试失败时提供更多信息，便于定位错误
5. 可以自动跟踪所有定义的测试
6. 测试高效快速

## 断言
1. 通过断言（Assertion）来判断功能是否符合预期
2. 结果分为 成功（success）、非致命错误（non-fatal failture）、和致命错误（fatal failture）
   1. 断言成功SCUCCEED（）继续执行
   2. 非致命错误FAIL（）继续执行
   3. 致命错误ADD_FAILURE（） 中止函数或程序崩溃

## 宏格式
1. EXPECT
   EXPECT_*失败时产生非致命故障，不会中止当前功能
2. ASSERT
   ASSERT_*失败时产生之命错误，中止功能
   直接从当前函数返回，可能会导致一些内存泄漏
3. 一般使用EXPECT_*，可以在测试中报告多个
4. 如果某个条件不成立的情况下，程序就无法运行，就使用ASSERT_*（如果条件是必要条件时）
   
## 自定义失败消息
1. 使用流操作符 << 将这些消息流到 断言宏中
2. 如
   1. ASSERT_EQ(x.size(),y.size()) << "Vector x and y are of unequal length";
   2. EXPECT_EQ(x[i],y[i]) << "Vector x and y differ at index";

## 功能测试
1. TEST
   1. TEST 是一个无返回值的宏函数
   2. 使用断言检测代码是否有效
   3. 所有断言成功，则测试成功
   4. TEST（测试用例集名称，归属的测试用例名称） 
    {
      测试内容
    }
   5. 测试用例集名称 和 归属的测试用例名称 必须都是有效的C++标识符，不包含下划线
2. TEST_F
   对于不同测试使用相同的测试数据进行测试
      
